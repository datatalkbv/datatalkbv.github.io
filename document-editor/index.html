<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Editor</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        /* Split view styles */

        @media print {
            body * {
                visibility: hidden;
            }

            #editor {
                visibility: visible;
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                padding: 0;
                margin: 0;
                box-shadow: none;
            }

            #editor * {
                visibility: visible;
            }

            .insertion,
            .deletion,
            .change-info,
            .resize-handle,
            .find-match {
                background: none !important;
                border: none !important;
                text-decoration: none !important;
            }
        }

        :root {
            --word-blue: #2b579a;
            --toolbar-bg: #f3f2f1;
            --border-color: #e6e6e6;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }

        .header {
            background-color: var(--word-blue);
            color: white;
            padding: 8px 16px;
            font-size: 14px;
            display: flex;
            align-items: center;
        }

        .header h1 {
            font-size: 14px;
            margin: 0;
            font-weight: normal;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh);
        }

        .content-container {
            display: flex;
            flex: 1;
            justify-content: center;
            padding: 0px;
            overflow: auto;
        }

        .editor-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        #editor {
            background: white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            width: 21cm;
            margin: 0 auto;
            padding: 2.54cm;
            box-sizing: border-box;
            outline: none;
            font-size: 11pt;
            line-height: 1.15;
            min-height: 29.7cm;
        }

        #editor:focus {
            outline: none;
        }

        #editor p {
            margin: 0;
            padding: 8px 0;
            line-height: 1.5;
        }

        .ribbon {
            background: var(--toolbar-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 2px 0;
        }

        .ribbon-tabs {
            display: flex;
            gap: 2px;
            padding: 0 8px;
            background: #fff;
            border-bottom: 1px solid var(--border-color);
        }

        .ribbon-tab {
            padding: 8px 16px;
            cursor: pointer;
            background: transparent;
            border: none;
            font-size: 13px;
            color: #444;
        }

        .ribbon-tab.active {
            background: var(--toolbar-bg);
            border-bottom: 2px solid var(--word-blue);
        }

        .ribbon-content {
            display: flex;
            padding: 4px;
            gap: 2px;
            background: var(--toolbar-bg);
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
            overflow-x: auto;
            flex-wrap: nowrap;
        }

        .ribbon-group {
            display: flex;
            flex-direction: column;
            padding: 4px 8px;
            border-right: 1px solid var(--border-color);
            min-width: 80px;
            flex-shrink: 0;
        }

        .ribbon-group-title {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 4px;
        }

        .ribbon-buttons {
            display: flex;
            gap: 2px;
            flex-wrap: nowrap;
            justify-content: center;
        }

        .ribbon button,
        .ribbon select {
            padding: 4px;
            cursor: pointer;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 3px;
            min-width: 48px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 11px;
            color: #444;
            position: relative;
        }

        .ribbon button:hover,
        .ribbon select:hover {
            background: rgba(0, 0, 0, 0.05);
            border-color: var(--border-color);
        }

        .ribbon button.active {
            background: rgba(0, 0, 0, 0.1);
            border-color: var(--border-color);
            position: relative;
        }

        .ribbon button.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background-color: var(--word-blue);
        }

        .ribbon i.bi {
            font-size: 24px;
        }

        .ribbon select {
            height: 32px;
            min-width: 120px;
        }

        .ribbon-group.small button {
            height: 32px;
            flex-direction: row;
            min-width: 32px;
            font-size: 14px;
        }

        .ribbon-group.small i.bi {
            font-size: 16px;
        }

        .toolbar button:hover,
        .toolbar select:hover {
            background: rgba(0, 0, 0, 0.05);
            border-color: var(--border-color);
        }

        .toolbar button.active {
            background: rgba(0, 0, 0, 0.1);
            border-color: var(--border-color);
        }

        .toolbar select {
            min-width: 120px;
            padding-right: 24px;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 4px center;
            background-size: 16px;
        }

        .toolbar .color-btn {
            position: relative;
            overflow: hidden;
        }

        .toolbar .color-btn input[type="color"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .toolbar i.bi {
            font-size: 16px;
        }

        .status {
            font-size: 0.8em;
            color: #666;
            display: flex;
            gap: 20px;
            padding: 10px;
            border-top: 1px solid var(--border-color);
            background: var(--toolbar-bg);
        }

        .insertion {
            background-color: #e6ffe6;
            text-decoration: none;
        }

        .deletion {
            background-color: #ffe6e6;
            text-decoration: line-through;
        }

        .tracking-on {
            background-color: #ffeb3b;
        }

        .current-change {
            outline: 2px solid #007bff;
            border-radius: 2px;
        }

        .change-info {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: none;
            max-width: 200px;
        }

        .insertion:hover .change-info,
        .deletion:hover .change-info {
            display: block;
        }

        .insertion {
            background-color: #e6ffe6;
            text-decoration: none;
            position: relative;
            border-bottom: 2px solid #4CAF50;
        }

        .deletion {
            background-color: #ffe6e6;
            text-decoration: line-through;
            position: relative;
            border-bottom: 2px solid #f44336;
        }

        .change-summary {
            position: fixed;
            right: 20px;
            top: 100px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 16px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: none;
            z-index: 1000;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .change-summary.visible {
            display: block;
        }

        .styles-panel {
            position: fixed;
            right: 20px;
            top: 100px;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 16px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: none;
            z-index: 1000;
            width: 250px;
        }

        .styles-panel.visible {
            display: block;
        }

        .styles-section {
            margin: 12px 0;
        }

        .styles-section h4 {
            margin: 8px 0;
            color: var(--word-blue);
        }

        .style-btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            text-align: left;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: white;
            cursor: pointer;
        }

        .style-btn:hover {
            background: var(--toolbar-bg);
        }

        /* Predefined styles */
        .heading1 {
            font-size: 24px;
            font-weight: bold;
            color: var(--word-blue);
            margin: 16px 0;
        }

        .heading2 {
            font-size: 20px;
            font-weight: bold;
            color: var(--word-blue);
            margin: 14px 0;
        }

        .heading3 {
            font-size: 16px;
            font-weight: bold;
            color: var(--word-blue);
            margin: 12px 0;
        }

        .quote {
            border-left: 3px solid var(--word-blue);
            padding-left: 12px;
            margin: 12px 0;
            font-style: italic;
            color: #666;
        }

        .code {
            font-family: monospace;
            background: #f5f5f5;
            padding: 12px;
            border-radius: 4px;
            margin: 12px 0;
        }

        .emphasis {
            font-style: italic;
            color: #666;
        }

        .strong {
            font-weight: bold;
            color: #333;
        }

        .code-inline {
            font-family: monospace;
            background: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 4px;
        }

        .small-caps {
            font-variant: small-caps;
            letter-spacing: 0.5px;
        }

        /* Custom spelling error style */
        #editor *::-webkit-spelling-error {
            text-decoration: underline red 2px;
        }

        #editor *::spelling-error {
            text-decoration: underline red 2px;
        }

        .change-entry {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }

        .change-entry:last-child {
            border-bottom: none;
        }

        .find-replace-dialog {
            position: fixed;
            top: 100px;
            right: 20px;
            background: white;
            padding: 16px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
            display: none;
            z-index: 1000;
            width: 300px;
        }

        .find-replace-dialog.visible {
            display: block;
        }

        .find-replace-dialog input[type="text"] {
            width: 100%;
            padding: 6px;
            margin: 4px 0;
            border: 1px solid var(--border-color);
            border-radius: 3px;
        }

        .find-replace-dialog .options {
            margin: 8px 0;
        }

        .find-replace-dialog .buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .find-replace-dialog button {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--toolbar-bg);
            cursor: pointer;
        }

        .find-replace-dialog button:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .find-match {
            background-color: #ffeb3b;
        }

        .find-match.current {
            background-color: #ffc107;
            outline: 2px solid #ff9800;
        }

        .properties-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
            z-index: 1000;
            width: 400px;
            display: none;
        }

        .properties-dialog.visible {
            display: block;
        }

        .properties-dialog h3 {
            margin-top: 0;
            color: var(--word-blue);
        }

        .properties-dialog .form-group {
            margin-bottom: 15px;
        }

        .properties-dialog label {
            display: block;
            margin-bottom: 5px;
            color: #666;
        }

        .properties-dialog input,
        .properties-dialog textarea {
            width: calc(100% - 16px);
            margin: 0 8px;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
        }

        .properties-dialog .buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .properties-dialog button {
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--toolbar-bg);
            cursor: pointer;
        }

        .properties-dialog button:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .properties-dialog .readonly-field {
            background: #f5f5f5;
            cursor: not-allowed;
        }

        /* Image resize styles */
        #editor img {
            max-width: 100%;
            position: relative;
        }

        .resize-handle {
            width: 8px;
            height: 8px;
            background-color: #007bff;
            position: absolute;
            border: 1px solid white;
            border-radius: 50%;
        }

        .resize-handle.nw {
            cursor: nw-resize;
            top: -4px;
            left: -4px;
        }

        .resize-handle.ne {
            cursor: ne-resize;
            top: -4px;
            right: -4px;
        }

        .resize-handle.sw {
            cursor: sw-resize;
            bottom: -4px;
            left: -4px;
        }

        .resize-handle.se {
            cursor: se-resize;
            bottom: -4px;
            right: -4px;
        }

        .resizable-image {
            position: relative;
            display: inline-block;
        }

        /* Table styles */
        #editor table {
            border-collapse: collapse;
            margin: 1em 0;
            min-width: 50%;
        }

        #editor td,
        #editor th {
            border: 1px solid #ccc;
            padding: 8px;
            min-width: 50px;
            position: relative;
        }

        /* Default theme */
        .table-theme-default th {
            background-color: #f3f2f1;
            font-weight: bold;
        }

        .table-theme-default td:hover,
        .table-theme-default th:hover {
            outline: 2px solid var(--word-blue);
        }

        /* Professional theme */
        .table-theme-professional {
            border: 2px solid #2b579a;
        }

        .table-theme-professional th {
            background-color: #2b579a;
            color: white;
            font-weight: bold;
            border: 1px solid #1e3f6f;
        }

        .table-theme-professional td {
            border: 1px solid #b8cce4;
        }

        .table-theme-professional tr:nth-child(even) {
            background-color: #f5f9ff;
        }

        /* Minimal theme */
        .table-theme-minimal {
            border: none;
        }

        .table-theme-minimal th {
            border-bottom: 2px solid #333;
            background: none;
            font-weight: bold;
        }

        .table-theme-minimal td {
            border: none;
            border-bottom: 1px solid #eee;
        }

        /* Colorful theme */
        .table-theme-colorful th {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            border: 1px solid #ff5252;
        }

        .table-theme-colorful tr:nth-child(even) {
            background-color: #fff5f5;
        }

        .table-theme-colorful td {
            border: 1px solid #ffcdd2;
        }

        /* Grid theme */
        .table-theme-grid {
            border: 2px solid #ddd;
        }

        .table-theme-grid th,
        .table-theme-grid td {
            border: 1px solid #ddd;
            padding: 12px;
        }

        .table-theme-grid th {
            background-color: #f8f9fa;
            border-bottom: 2px solid #ddd;
        }

        /* Comments styles */
        .comments-panel {
            position: fixed;
            right: 0;
            top: 100px;
            bottom: 0;
            width: 300px;
            background: white;
            border-left: 1px solid var(--border-color);
            padding: 16px;
            overflow-y: auto;
            display: none;
        }

        .comments-panel.visible {
            display: block;
        }

        .comment-entry {
            padding: 8px;
            margin-bottom: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            border-left: 3px solid var(--word-blue);
        }

        .comment-text {
            margin-bottom: 4px;
        }

        .comment-meta {
            font-size: 0.8em;
            color: #666;
            position: relative;
        }

        .delete-comment {
            position: absolute;
            right: 0;
            top: 0;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .delete-comment:hover {
            background: #ff0000;
        }

        .commented-text {
            background-color: #fff3cd;
            position: relative;
        }

        .commented-text.highlight {
            background-color: #ffc107;
        }

        .comment-indicator {
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            background-color: var(--word-blue);
            border-radius: 50%;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div class="main-container">
        <div class="header">
            <h1>Document Editor</h1>
        </div>

        <div class="ribbon">
            <div class="ribbon-tabs">
                <button class="ribbon-tab" data-tab="file">File</button>
                <button class="ribbon-tab active" data-tab="format">Format</button>
                <button class="ribbon-tab" data-tab="insert">Insert</button>
                <button class="ribbon-tab" data-tab="review">Review</button>
            </div>
            <div class="ribbon-content" id="formatTab">
                <!-- Clipboard -->
                <div class="ribbon-group">
                    <div class="ribbon-buttons">
                        <button onclick="editor.paste()" title="Paste">
                            <i class="bi bi-clipboard"></i>
                            <span>Paste</span>
                        </button>
                        <button onclick="editor.cut()" title="Cut">
                            <i class="bi bi-scissors"></i>
                            <span>Cut</span>
                        </button>
                        <button onclick="editor.copy()" title="Copy">
                            <i class="bi bi-files"></i>
                            <span>Copy</span>
                        </button>
                    </div>
                    <div class="ribbon-group-title">Clipboard</div>
                </div>



                <!-- Find -->
                <div class="ribbon-group">
                    <div class="ribbon-buttons">
                        <button onclick="editor.toggleFindReplace()" title="Find & Replace">
                            <i class="bi bi-search"></i>
                            <span>Find</span>
                        </button>
                    </div>
                    <div class="ribbon-group-title">Find</div>
                </div>

                <!-- Font -->
                <div class="ribbon-group">
                    <div class="ribbon-buttons" style="display: flex; gap: 2px; align-items: center;">
                        <select onchange="formatDoc('fontName', this.value)" style="min-width: 100px;">
                            <option value="">Calibri</option>
                            <option value="Arial">Arial</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Calibri">Calibri</option>
                            <option value="Cambria">Cambria</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Segoe UI">Segoe UI</option>
                        </select>
                        <select id="fontSizeSelect" onchange="formatDoc('fontSize', this.value)"
                            style="min-width: 45px;">
                            <option value="3">11</option>
                            <option value="1">8</option>
                            <option value="2">10</option>
                            <option value="4">12</option>
                            <option value="5">14</option>
                            <option value="6">16</option>
                            <option value="7">18</option>
                        </select>
                        <button onclick="editor.increaseFontSize()" title="Increase Font Size"
                            style="padding: 2px; min-width: 32px;">
                            <i class="bi bi-plus"></i>A
                        </button>
                        <button onclick="editor.decreaseFontSize()" title="Decrease Font Size"
                            style="padding: 2px; min-width: 32px;">
                            <i class="bi bi-dash"></i>A
                        </button>
                        <button onclick="formatDoc('bold')" title="Bold" style="padding: 2px; min-width: 32px;">
                            <i class="bi bi-type-bold"></i>
                        </button>
                        <button onclick="formatDoc('italic')" title="Italic" style="padding: 2px; min-width: 32px;">
                            <i class="bi bi-type-italic"></i>
                        </button>
                        <button onclick="formatDoc('underline')" title="Underline"
                            style="padding: 2px; min-width: 32px;">
                            <i class="bi bi-type-underline"></i>
                        </button>
                        <button onclick="formatDoc('strikeThrough')" title="Strikethrough"
                            style="padding: 2px; min-width: 32px;">
                            <i class="bi bi-type-strikethrough"></i>
                        </button>
                        <button onclick="editor.clearFormatting()" title="Clear Formatting"
                            style="padding: 2px; min-width: 32px;">
                            <i class="bi bi-eraser"></i>
                        </button>
                        <button onclick="editor.toggleStylesPanel()" title="Styles"
                            style="padding: 2px; min-width: 32px;">
                            <i class="bi bi-type"></i>
                        </button>
                    </div>
                    <div class="ribbon-group-title">Font</div>
                </div>

                <!-- Paragraph -->
                <div class="ribbon-group">
                    <div class="ribbon-buttons small">
                        <button onclick="formatDoc('justifyLeft')" title="Align Left">
                            <i class="bi bi-text-left"></i>
                        </button>
                        <button onclick="formatDoc('justifyCenter')" title="Center">
                            <i class="bi bi-text-center"></i>
                        </button>
                        <button onclick="formatDoc('justifyRight')" title="Align Right">
                            <i class="bi bi-text-right"></i>
                        </button>
                        <button onclick="formatDoc('justifyFull')" title="Justify">
                            <i class="bi bi-justify"></i>
                        </button>
                    </div>
                    <div class="ribbon-buttons small">
                        <button onclick="formatDoc('insertUnorderedList')" title="Bullet List">
                            <i class="bi bi-list-ul"></i>
                        </button>
                        <button onclick="formatDoc('insertOrderedList')" title="Numbered List">
                            <i class="bi bi-list-ol"></i>
                        </button>
                        <button onclick="formatDoc('outdent')" title="Decrease Indent">
                            <i class="bi bi-text-indent-left"></i>
                        </button>
                        <button onclick="formatDoc('indent')" title="Increase Indent">
                            <i class="bi bi-text-indent-right"></i>
                        </button>
                    </div>
                    <div class="ribbon-group-title">Paragraph</div>
                </div>

                <!-- Tables -->
                <div class="ribbon-group" id="tableGroup" style="display: none;">
                    <div class="ribbon-buttons">
                        <button onclick="editor.insertTable()" title="Insert Table">
                            <i class="bi bi-table"></i>
                            <span>Table</span>
                        </button>
                        <select onchange="editor.applyTableTheme(this.value)" title="Table Theme">
                            <option value="default">Default Theme</option>
                            <option value="professional">Professional</option>
                            <option value="minimal">Minimal</option>
                            <option value="colorful">Colorful</option>
                            <option value="grid">Grid</option>
                        </select>
                    </div>
                    <div class="ribbon-buttons small">
                        <button onclick="editor.addRow()" title="Add Row">
                            <i class="bi bi-plus"></i>Row
                        </button>
                        <button onclick="editor.addColumn()" title="Add Column">
                            <i class="bi bi-plus"></i>Col
                        </button>
                        <button onclick="editor.deleteRow()" title="Delete Row">
                            <i class="bi bi-dash"></i>Row
                        </button>
                        <button onclick="editor.deleteColumn()" title="Delete Column">
                            <i class="bi bi-dash"></i>Col
                        </button>
                    </div>
                    <div class="ribbon-group-title">Table</div>
                </div>

            </div>

            <div class="ribbon-content" id="fileTab" style="display: none;">
                <!-- File operations -->
                <div class="ribbon-group">
                    <div class="ribbon-buttons">
                        <button onclick="editor.importDocument()" title="Import">
                            <i class="bi bi-file-earmark-arrow-down"></i>
                            <span>Import</span>
                        </button>
                        <button onclick="editor.exportDocument()" title="Export">
                            <i class="bi bi-file-earmark-arrow-up"></i>
                            <span>Export</span>
                        </button>
                        <button onclick="editor.showProperties()" title="Properties">
                            <i class="bi bi-info-circle"></i>
                            <span>Properties</span>
                        </button>
                        <button onclick="editor.exportAsDocx()" title="Export as DOCX">
                            <i class="bi bi-file-earmark-word"></i>
                            <span>Export DOCX</span>
                        </button>
                    </div>
                    <div class="ribbon-group-title">File Operations</div>
                </div>
            </div>

            <div class="ribbon-content" id="insertTab" style="display: none;">
                <!-- Insert tab content -->
                <div class="ribbon-group">
                    <div class="ribbon-buttons">
                        <button onclick="editor.insertTable()" title="Insert Table">
                            <i class="bi bi-table"></i>
                            <span>Table</span>
                        </button>
                        <button onclick="document.getElementById('imageInput').click()" title="Insert Image">
                            <i class="bi bi-image"></i>
                            <span>Image</span>
                        </button>
                    </div>
                    <div class="ribbon-group-title">Insert</div>
                </div>
            </div>

            <div class="ribbon-content" id="reviewTab" style="display: none;">
                <!-- Comments -->
                <div class="ribbon-group">
                    <div class="ribbon-buttons">
                        <button onclick="editor.addComment()" title="Add Comment">
                            <i class="bi bi-chat-right-text"></i>
                            <span>New Comment</span>
                        </button>
                        <button onclick="editor.toggleComments()" title="Show Comments">
                            <i class="bi bi-chat-right"></i>
                            <span>Show Comments</span>
                        </button>
                    </div>
                    <div class="ribbon-group-title">Comments</div>
                </div>
                <div class="ribbon-group">
                    <div class="ribbon-buttons">
                        <button onclick="editor.toggleSpellCheck()" title="Spell Check">
                            <i class="bi bi-spellcheck"></i>
                            <span>Spell Check</span>
                        </button>
                        <button onclick="editor.toggleAutoCorrect()" title="Auto Correct">
                            <i class="bi bi-pencil-square"></i>
                            <span>Auto Correct</span>
                        </button>
                    </div>
                    <div class="ribbon-group-title">Proofing</div>
                </div>

                <div class="ribbon-group">
                    <div class="ribbon-buttons">
                        <button id="trackChanges" onclick="editor.toggleTrackChanges()" title="Track Changes">
                            <i class="bi bi-pencil-square"></i>
                            <span>Track Changes</span>
                        </button>
                        <button onclick="editor.toggleChangeSummary()" title="Show Changes">
                            <i class="bi bi-list-check"></i>
                            <span>Show Changes</span>
                        </button>
                    </div>
                    <div class="ribbon-buttons small">
                        <button onclick="editor.previousChange()" title="Previous">
                            <i class="bi bi-arrow-left-circle"></i>
                        </button>
                        <button onclick="editor.nextChange()" title="Next">
                            <i class="bi bi-arrow-right-circle"></i>
                        </button>
                        <button onclick="editor.acceptCurrentChange()" title="Accept">
                            <i class="bi bi-check-circle"></i>
                        </button>
                        <button onclick="editor.rejectCurrentChange()" title="Reject">
                            <i class="bi bi-x-circle"></i>
                        </button>
                    </div>
                    <div class="ribbon-group-title">Review</div>
                </div>
            </div>

            <input type="file" id="importFile" accept=".html,.docx" style="display: none"
                onchange="editor.handleImportFile(event)">
            <input type="file" id="imageInput" accept="image/*" style="display: none"
                onchange="editor.insertImageFromFile(this.files[0])">
        </div>

        <div class="content-container">
            <div class="editor-container" id="mainEditorContainer">
                <div id="editor" contenteditable="true">
                    <p>Start typing here. This is a simple HTML editor that works directly with the DOM.</p>
                    <p>Try using the formatting buttons above or just type normally.</p>
                </div>
            </div>
        </div>

        <div class="status">
            <div>Words: <span id="wordCount">0</span></div>
            <div>Characters: <span id="charCount">0</span></div>
            <div>Characters (no spaces): <span id="charNoSpacesCount">0</span></div>
            <div>Paragraphs: <span id="paragraphCount">0</span></div>
            <div>Sentences: <span id="sentenceCount">0</span></div>
        </div>

        <div class="find-replace-dialog" id="findReplaceDialog">
            <div>
                <input type="text" id="findInput" placeholder="Find">
                <input type="text" id="replaceInput" placeholder="Replace with">
            </div>
            <div class="options">
                <label>
                    <input type="checkbox" id="matchCase"> Match case
                </label>
                <label>
                    <input type="checkbox" id="wholeWord"> Whole words
                </label>
            </div>
            <div class="buttons">
                <button onclick="editor.findNext()">Find Next</button>
                <button onclick="editor.replace()">Replace</button>
                <button onclick="editor.replaceAll()">Replace All</button>
                <button onclick="editor.toggleFindReplace()">Close</button>
            </div>
        </div>

        <div id="changeSummary" class="change-summary">
            <h3>Changes Summary</h3>
            <div id="changesList"></div>
        </div>

        <div id="propertiesDialog" class="properties-dialog">
            <h3>Document Properties</h3>
            <div class="form-group">
                <label>Title</label>
                <input type="text" id="docTitle">
            </div>
            <div class="form-group">
                <label>Author</label>
                <input type="text" id="docAuthor">
            </div>
            <div class="form-group">
                <label>Subject</label>
                <input type="text" id="docSubject">
            </div>
            <div class="form-group">
                <label>Keywords</label>
                <input type="text" id="docKeywords">
            </div>
            <div class="form-group">
                <label>Created</label>
                <input type="text" id="docCreated" class="readonly-field" readonly>
            </div>
            <div class="form-group">
                <label>Last Modified</label>
                <input type="text" id="docModified" class="readonly-field" readonly>
            </div>
            <div class="form-group">
                <label>Comments</label>
                <textarea id="docComments" rows="3"></textarea>
            </div>
            <div class="buttons">
                <button onclick="editor.closeProperties()">Cancel</button>
                <button onclick="editor.saveProperties()">Save</button>
            </div>
        </div>

        <div id="stylesPanel" class="styles-panel">
            <h3>Styles</h3>
            <div class="styles-section">
                <h4>Paragraph Styles</h4>
                <button onclick="editor.applyStyle('normal')" class="style-btn">Normal</button>
                <button onclick="editor.applyStyle('heading1')" class="style-btn">Heading 1</button>
                <button onclick="editor.applyStyle('heading2')" class="style-btn">Heading 2</button>
                <button onclick="editor.applyStyle('heading3')" class="style-btn">Heading 3</button>
                <button onclick="editor.applyStyle('quote')" class="style-btn">Quote</button>
                <button onclick="editor.applyStyle('code')" class="style-btn">Code</button>
            </div>
            <div class="styles-section">
                <h4>Character Styles</h4>
                <button onclick="editor.applyCharacterStyle('emphasis')" class="style-btn">Emphasis</button>
                <button onclick="editor.applyCharacterStyle('strong')" class="style-btn">Strong</button>
                <button onclick="editor.applyCharacterStyle('code-inline')" class="style-btn">Inline Code</button>
                <button onclick="editor.applyCharacterStyle('highlight')" class="style-btn">Highlight</button>
                <button onclick="editor.applyCharacterStyle('small-caps')" class="style-btn">Small Caps</button>
            </div>
        </div>

        <!-- Comments Panel -->
        <div id="commentsPanel" class="comments-panel">
            <h3>Comments</h3>
            <div id="commentsList"></div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script>
            async function parseDocx(file) {
                const arrayBuffer = await file.arrayBuffer();
                const dataView = new DataView(arrayBuffer);

                if (dataView.getUint32(0) !== 0x504b0304) {
                    throw new Error('Not a valid DOCX file');
                }

                async function extractDocumentXml() {
                    try {
                        const zip = new JSZip();
                        await zip.loadAsync(arrayBuffer);

                        const documentXml = zip.file('word/document.xml');
                        if (!documentXml) {
                            throw new Error('Could not find word/document.xml in the DOCX file');
                        }

                        const content = await documentXml.async('string');
                        return content;
                    } catch (error) {
                        throw new Error(`Failed to extract document.xml: ${error.message}`);
                    }
                }

                function convertToHtml(xmlString) {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
                    let html = '<div class="docx-content">';

                    function processTextNode(node) {
                        let text = node.textContent;
                        let formattedText = text;

                        let run = node;
                        while (run && run.tagName !== 'w:r') {
                            run = run.parentNode;
                        }
                        if (run) {
                            const rPr = run.getElementsByTagName('w:rPr')[0];
                            if (rPr) {
                                if (rPr.getElementsByTagName('w:b').length > 0) {
                                    formattedText = `<strong>${formattedText}</strong>`;
                                }
                                if (rPr.getElementsByTagName('w:i').length > 0) {
                                    formattedText = `<em>${formattedText}</em>`;
                                }
                                if (rPr.getElementsByTagName('w:u').length > 0) {
                                    formattedText = `<u>${formattedText}</u>`;
                                }
                            }
                        }

                        return formattedText;
                    }

                    function processParagraph(p) {
                        const pPr = p.getElementsByTagName('w:pPr')[0];
                        let tag = 'p';
                        let classes = [];

                        if (pPr) {
                            const pStyle = pPr.getElementsByTagName('w:pStyle')[0];
                            const styleId = pStyle?.getAttribute('w:val');
                            if (styleId?.startsWith('Heading')) {
                                const level = styleId.replace('Heading', '');
                                if (!isNaN(level) && level >= 1 && level <= 6) {
                                    tag = `h${level}`;
                                }
                            }

                            const jc = pPr.getElementsByTagName('w:jc')[0];
                            const alignment = jc?.getAttribute('w:val');
                            if (alignment) {
                                classes.push(`align-${alignment}`);
                            }

                            const numPr = pPr.getElementsByTagName('w:numPr')[0];
                            if (numPr) {
                                tag = 'li';
                            }
                        }

                        const textNodes = p.getElementsByTagName('w:t');
                        const textContent = Array.from(textNodes)
                            .map(t => processTextNode(t))
                            .join('');

                        const classAttr = classes.length ? ` class="${classes.join(' ')}"` : '';
                        return textContent ? `<${tag}${classAttr}>${textContent}</${tag}>` : '';
                    }

                    const paragraphs = xmlDoc.getElementsByTagName('w:p');
                    let inList = false;

                    for (const p of paragraphs) {
                        const pPr = p.getElementsByTagName('w:pPr')[0];
                        const isListItem = pPr?.getElementsByTagName('w:numPr')[0];

                        if (isListItem && !inList) {
                            html += '<ul>';
                            inList = true;
                        } else if (!isListItem && inList) {
                            html += '</ul>';
                            inList = false;
                        }

                        html += processParagraph(p);
                    }

                    if (inList) {
                        html += '</ul>';
                    }

                    html += '</div>';

                    const style = `
                        <style>
                            .docx-content { font-family: Arial, sans-serif; line-height: 1.5; }
                            .align-center { text-align: center; }
                            .align-right { text-align: right; }
                            .align-justify { text-align: justify; }
                            h1, h2, h3, h4, h5, h6 { margin: 1em 0 0.5em; }
                            p { margin: 0 0 1em; }
                            ul { margin: 0 0 1em 2em; }
                        </style>
                    `;

                    return style + html;
                }

                try {
                    const xmlContent = await extractDocumentXml();
                    return convertToHtml(xmlContent);
                } catch (error) {
                    throw new Error(`Failed to parse DOCX: ${error.message}`);
                }
            }

            class SimpleEditor {
                constructor(elementId) {
                    this.deletedCommentIds = new Set();
                    this.editor = document.getElementById(elementId);
                    this.charCount = document.getElementById('charCount');
                    this.trackChangesEnabled = false;
                    this.comments = [];
                    this.nextCommentId = 1;
                    this.trackChangesBtn = document.getElementById('trackChanges');
                    this.spellCheckEnabled = true;
                    this.autoCorrectEnabled = true;
                    this.currentChangeIndex = -1;
                    this.findReplaceDialog = document.getElementById('findReplaceDialog');
                    this.currentFindIndex = -1;
                    this.findMatches = [];
                    this.setupEventListeners();
                    this.updateCharCount();
                    this.setupAutoSave();
                }


                setupAutoSave() {
                    // Auto-save every 5 seconds
                    setInterval(() => this.autoSave(), 5000);

                    // Load content on startup
                    this.autoLoad();

                    // Save on any input
                    this.editor.addEventListener('input', () => {
                        clearTimeout(this.saveTimeout);
                        this.saveTimeout = setTimeout(() => this.autoSave(), 1000);
                    });
                }

                autoSave() {
                    const content = this.editor.innerHTML;
                    const timestamp = new Date().toISOString();
                    localStorage.setItem('documentContent', content);
                    localStorage.setItem('lastSaved', timestamp);

                    // Update last modified time
                    this.properties.modified = timestamp;
                    this.saveProperties(false); // Don't close dialog during auto-save
                }

                showProperties() {
                    const dialog = document.getElementById('propertiesDialog');
                    dialog.classList.add('visible');

                    // Fill in the form
                    document.getElementById('docTitle').value = this.properties.title || '';
                    document.getElementById('docAuthor').value = this.properties.author || '';
                    document.getElementById('docSubject').value = this.properties.subject || '';
                    document.getElementById('docKeywords').value = this.properties.keywords || '';
                    document.getElementById('docComments').value = this.properties.comments || '';
                    document.getElementById('docCreated').value = new Date(this.properties.created).toLocaleString();
                    document.getElementById('docModified').value = new Date(this.properties.modified).toLocaleString();
                }

                closeProperties() {
                    document.getElementById('propertiesDialog').classList.remove('visible');
                }

                saveProperties(closeDialog = true) {
                    if (document.getElementById('propertiesDialog').classList.contains('visible')) {
                        // Update from form
                        this.properties.title = document.getElementById('docTitle').value;
                        this.properties.author = document.getElementById('docAuthor').value;
                        this.properties.subject = document.getElementById('docSubject').value;
                        this.properties.keywords = document.getElementById('docKeywords').value;
                        this.properties.comments = document.getElementById('docComments').value;
                        if (closeDialog) {
                            this.closeProperties();
                        }
                    }

                    // Save to localStorage
                    localStorage.setItem('documentProperties', JSON.stringify(this.properties));
                }

                autoLoad() {
                    const content = localStorage.getItem('documentContent');
                    if (content) {
                        this.editor.innerHTML = content;
                        this.updateCharCount();
                    }

                    // Load document properties
                    this.properties = JSON.parse(localStorage.getItem('documentProperties') || '{}');
                    if (!this.properties.created) {
                        this.properties = {
                            title: '',
                            author: '',
                            subject: '',
                            keywords: '',
                            comments: '',
                            created: new Date().toISOString(),
                            modified: new Date().toISOString()
                        };
                        this.saveProperties();
                    }
                }

                exportDocument() {
                    // Create a full HTML document with meta tags
                    const docTemplate = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="doc-title" content="${this.properties.title || ''}">
    <meta name="doc-author" content="${this.properties.author || ''}">
    <meta name="doc-subject" content="${this.properties.subject || ''}">
    <meta name="doc-keywords" content="${this.properties.keywords || ''}">
    <meta name="doc-comments" content="${this.properties.comments || ''}">
    <meta name="doc-created" content="${this.properties.created || ''}">
    <meta name="doc-modified" content="${this.properties.modified || ''}">
</head>
<body>
${this.editor.innerHTML}
</body>
</html>`;
                    const blob = new Blob([docTemplate], { type: 'text/html' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'document.html';
                    a.click();
                    window.URL.revokeObjectURL(url);
                }

                importDocument() {
                    document.getElementById('importFile').click();
                }

                async handleImportFile(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    if (confirm('Import this document? Current content will be replaced.')) {
                        if (file.name.toLowerCase().endsWith('.docx')) {
                            try {
                                const htmlContent = await parseDocx(file);
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(htmlContent, 'text/html');
                                const content = doc.querySelector('.docx-content');
                                if (content) {
                                    this.editor.innerHTML = content.innerHTML;
                                    this.updateCharCount();
                                } else {
                                    throw new Error('Could not parse DOCX content');
                                }
                            } catch (error) {
                                alert(`Error importing DOCX: ${error.message}`);
                                console.error(error);
                            }
                        } else {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(e.target.result, 'text/html');

                                // Extract meta tags
                                const metaTags = doc.getElementsByTagName('meta');
                                const newProperties = {};
                                for (let meta of metaTags) {
                                    const name = meta.getAttribute('name');
                                    if (name && name.startsWith('doc-')) {
                                        const prop = name.replace('doc-', '');
                                        newProperties[prop] = meta.getAttribute('content');
                                    }
                                }

                                // Update properties if found
                                if (Object.keys(newProperties).length > 0) {
                                    this.properties = {
                                        ...this.properties,
                                        ...newProperties
                                    };
                                    this.saveProperties(false);
                                }

                                // Update content
                                this.editor.innerHTML = doc.body.innerHTML;
                                this.updateCharCount();
                            };
                            reader.readAsText(file);
                        }
                        event.target.value = ''; // Reset file input
                    }
                }


                toggleTrackChanges() {
                    this.trackChangesEnabled = !this.trackChangesEnabled;
                    this.trackChangesBtn.classList.toggle('tracking-on');
                }

                markChange(isInsertion, text) {
                    if (!this.trackChangesEnabled) return text;

                    const span = document.createElement('span');
                    span.className = isInsertion ? 'insertion' : 'deletion';
                    span.dataset.author = 'Current User';
                    span.dataset.timestamp = new Date().toISOString();
                    span.textContent = text;

                    const info = document.createElement('div');
                    info.className = 'change-info';
                    info.textContent = `${isInsertion ? 'Added' : 'Removed'} by ${span.dataset.author} on ${new Date(span.dataset.timestamp).toLocaleString()}`;
                    span.appendChild(info);

                    this.updateChangeSummary();
                    return span.outerHTML;
                }

                previousChange() {
                    const currentHighlight = this.editor.querySelector('.current-change');
                    if (currentHighlight) {
                        currentHighlight.classList.remove('current-change');
                    }

                    const changes = [...this.editor.querySelectorAll('.insertion, .deletion')];

                    if (changes.length === 0) {
                        this.currentChangeIndex = -1;
                        return;
                    }

                    this.currentChangeIndex = this.currentChangeIndex <= 0 ?
                        changes.length - 1 : this.currentChangeIndex - 1;

                    const currentChange = changes[this.currentChangeIndex];
                    currentChange.classList.add('current-change');
                    currentChange.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                rejectCurrentChange() {
                    const currentChange = this.editor.querySelector('.current-change');
                    if (!currentChange) return;

                    if (currentChange.classList.contains('insertion')) {
                        currentChange.remove();
                    } else if (currentChange.classList.contains('deletion')) {
                        const textNode = document.createTextNode(currentChange.textContent);
                        currentChange.parentNode.replaceChild(textNode, currentChange);
                    }

                    this.currentChangeIndex--;
                    this.nextChange();
                    this.updateChangeSummary();
                }

                toggleChangeSummary() {
                    const summary = document.getElementById('changeSummary');
                    summary.classList.toggle('visible');
                    this.updateChangeSummary();
                }

                updateChangeSummary() {
                    const changesList = document.getElementById('changesList');
                    const changes = [...this.editor.querySelectorAll('.insertion, .deletion')];

                    changesList.innerHTML = '';

                    changes.forEach((change, index) => {
                        const entry = document.createElement('div');
                        entry.className = 'change-entry';
                        const type = change.classList.contains('insertion') ? 'Added' : 'Removed';
                        const author = change.dataset.author || 'Unknown';
                        const time = new Date(change.dataset.timestamp).toLocaleString();

                        entry.innerHTML = `
                        <div><strong>${type}:</strong> "${change.textContent}"</div>
                        <div><small>By ${author} on ${time}</small></div>
                    `;

                        changesList.appendChild(entry);
                    });
                }

                setupEventListeners() {
                    this.editor.addEventListener('keydown', this.handleKeyDown.bind(this));
                    this.editor.addEventListener('input', this.handleInput.bind(this));
                    this.editor.addEventListener('paste', this.handlePaste.bind(this));
                    this.editor.addEventListener('click', this.handleClick.bind(this));
                    this.editor.addEventListener('keyup', this.handleClick.bind(this));

                    // Add global keyboard shortcuts
                    document.addEventListener('keydown', (e) => {
                        if (e.metaKey || e.ctrlKey) {
                            if (e.key === 'f') {
                                e.preventDefault();
                                this.toggleFindReplace();
                            } else if (e.key === 'p') {
                                e.preventDefault();
                                window.print();
                            }
                        }
                    });

                    // Set initial spell check state
                    this.editor.spellcheck = this.spellCheckEnabled;
                    this.editor.setAttribute('autocorrect', this.autoCorrectEnabled ? 'on' : 'off');

                    // Add tab switching functionality
                    document.querySelectorAll('.ribbon-tab').forEach(tab => {
                        tab.addEventListener('click', () => {
                            // Remove active class from all tabs
                            document.querySelectorAll('.ribbon-tab').forEach(t => t.classList.remove('active'));
                            // Add active class to clicked tab
                            tab.classList.add('active');

                            // Hide all tab contents
                            document.querySelectorAll('.ribbon-content').forEach(content => {
                                content.style.display = 'none';
                            });

                            // Show selected tab content
                            const tabId = tab.getAttribute('data-tab') + 'Tab';
                            document.getElementById(tabId).style.display = 'flex';
                        });
                    });
                }

                handleKeyDown(e) {
                    // Handle Enter key
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.createNewParagraph();
                    }

                    // Handle Backspace key
                    if (e.key === 'Backspace') {
                        const selection = window.getSelection();
                        const range = selection.getRangeAt(0);

                        // Track deletions before they happen
                        if (this.trackChangesEnabled) {
                            if (!range.collapsed) {
                                // Text selection deletion
                                e.preventDefault();
                                const deletedContent = range.toString();
                                const span = document.createElement('span');
                                span.className = 'deletion';
                                span.textContent = deletedContent;
                                range.deleteContents();
                                range.insertNode(span);
                                range.setStartAfter(span);
                                range.setEndAfter(span);
                                selection.removeAllRanges();
                                selection.addRange(range);
                            } else if (range.startOffset > 0) {
                                // Single character deletion
                                e.preventDefault();
                                const container = range.startContainer;
                                const offset = range.startOffset;
                                const deletedChar = container.textContent.charAt(offset - 1);

                                container.textContent = container.textContent.slice(0, offset - 1) +
                                    container.textContent.slice(offset);

                                const span = document.createElement('span');
                                span.className = 'deletion';
                                span.textContent = deletedChar;

                                range.setStart(container, offset - 1);
                                range.setEnd(container, offset - 1);
                                range.insertNode(span);

                                // Move cursor one position to the left of the deletion mark
                                range.setStart(container, Math.max(0, offset - 1));
                                range.setEnd(container, Math.max(0, offset - 1));
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }
                        }

                        // Handle paragraph merging
                        if (range.startOffset === 0) {
                            const currentParagraph = this.getClosestParagraph(range.startContainer);
                            if (currentParagraph && currentParagraph.previousElementSibling) {
                                e.preventDefault();
                                this.mergeParagraphs(currentParagraph.previousElementSibling, currentParagraph);
                            }
                        }
                    }
                }

                handleInput(e) {
                    // Check for deleted comments
                    if (e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward') {
                        this.checkForDeletedComments();
                    }

                    if (this.trackChangesEnabled && e.inputType === 'insertText' && e.data) {
                        // Remove the character that was just inserted
                        document.execCommand('undo');

                        const selection = window.getSelection();
                        const range = selection.getRangeAt(0);

                        // Create and insert the marked span
                        const span = document.createElement('span');
                        span.className = 'insertion';
                        span.textContent = e.data;

                        range.deleteContents();
                        range.insertNode(span);

                        // Position cursor after insertion
                        range.setStartAfter(span);
                        range.setEndAfter(span);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }

                    // Ensure content is always wrapped in paragraphs
                    if (!this.editor.querySelector('p')) {
                        this.wrapTextInParagraph();
                    }
                    this.updateCharCount();
                }

                handlePaste(e) {
                    e.preventDefault();
                    const text = e.clipboardData.getData('text/plain');
                    document.execCommand('insertText', false, text);
                }

                createNewParagraph() {
                    document.execCommand('insertParagraph', false);
                }

                wrapTextInParagraph() {
                    const content = this.editor.innerHTML;
                    this.editor.innerHTML = `<p>${content}</p>`;
                    this.moveCursorToEnd();
                }

                mergeParagraphs(p1, p2) {
                    if (p1 && p2) {
                        const pos = p1.textContent.length;
                        p1.textContent += p2.textContent;
                        p2.remove();

                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.setStart(p1.firstChild, pos);
                        range.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                }

                getClosestParagraph(node) {
                    while (node && node.nodeName !== 'P') {
                        node = node.parentNode;
                    }
                    return node;
                }

                moveCursorToEnd() {
                    const range = document.createRange();
                    const sel = window.getSelection();
                    const lastParagraph = this.editor.lastChild;
                    if (lastParagraph) {
                        range.setStartAfter(lastParagraph.lastChild || lastParagraph);
                        range.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                }

                setLineHeight(value) {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const paragraph = this.getClosestParagraph(range.commonAncestorContainer);

                    if (paragraph) {
                        paragraph.style.lineHeight = value;
                    }
                }

                updateCharCount() {
                    const text = this.editor.textContent;
                    const words = text.trim().split(/\s+/).filter(word => word.length > 0);
                    const chars = text.length;
                    const charsNoSpaces = text.replace(/\s/g, '').length;
                    const paragraphs = this.editor.getElementsByTagName('p').length;
                    const sentences = text.split(/[.!?]+\s/).filter(sentence => sentence.length > 0);

                    document.getElementById('wordCount').textContent = words.length;
                    document.getElementById('charCount').textContent = chars;
                    document.getElementById('charNoSpacesCount').textContent = charsNoSpaces;
                    document.getElementById('paragraphCount').textContent = paragraphs;
                    document.getElementById('sentenceCount').textContent = sentences.length;
                }

                acceptAllChanges() {
                    // Handle insertions
                    const insertions = this.editor.querySelectorAll('.insertion');
                    insertions.forEach(insertion => {
                        const textNode = document.createTextNode(insertion.textContent);
                        insertion.parentNode.replaceChild(textNode, insertion);
                    });

                    // Handle deletions
                    const deletions = this.editor.querySelectorAll('.deletion');
                    deletions.forEach(deletion => {
                        deletion.remove();
                    });

                    this.currentChangeIndex = -1;
                }

                nextChange() {
                    // Remove highlight from current change
                    const currentHighlight = this.editor.querySelector('.current-change');
                    if (currentHighlight) {
                        currentHighlight.classList.remove('current-change');
                    }

                    // Get all changes
                    const changes = [...this.editor.querySelectorAll('.insertion, .deletion')];

                    if (changes.length === 0) {
                        this.currentChangeIndex = -1;
                        return;
                    }

                    // Move to next change
                    this.currentChangeIndex = (this.currentChangeIndex + 1) % changes.length;

                    // Highlight the current change
                    const currentChange = changes[this.currentChangeIndex];
                    currentChange.classList.add('current-change');

                    // Scroll change into view
                    currentChange.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }

                acceptCurrentChange() {
                    const currentChange = this.editor.querySelector('.current-change');
                    if (!currentChange) return;

                    if (currentChange.classList.contains('insertion')) {
                        const textNode = document.createTextNode(currentChange.textContent);
                        currentChange.parentNode.replaceChild(textNode, currentChange);
                    } else if (currentChange.classList.contains('deletion')) {
                        currentChange.remove();
                    }

                    // Move to next change
                    this.currentChangeIndex--;  // Decrement because we removed a change
                    this.nextChange();
                }

                toggleFindReplace() {
                    this.findReplaceDialog.classList.toggle('visible');
                    if (this.findReplaceDialog.classList.contains('visible')) {
                        document.getElementById('findInput').focus();
                        this.clearFindMatches();
                    }
                }

                clearFindMatches() {
                    const matches = this.editor.querySelectorAll('.find-match');
                    matches.forEach(match => {
                        const text = match.textContent;
                        match.parentNode.replaceChild(document.createTextNode(text), match);
                    });
                    this.currentFindIndex = -1;
                    this.findMatches = [];
                }

                findNext() {
                    const searchText = document.getElementById('findInput').value;
                    const matchCase = document.getElementById('matchCase').checked;
                    const wholeWord = document.getElementById('wholeWord').checked;

                    if (!searchText) return;

                    this.clearFindMatches();

                    const text = this.editor.textContent;
                    let matches = [];
                    let searchRegex;

                    if (wholeWord) {
                        searchRegex = new RegExp(`\\b${this.escapeRegExp(searchText)}\\b`, matchCase ? 'g' : 'gi');
                    } else {
                        searchRegex = new RegExp(this.escapeRegExp(searchText), matchCase ? 'g' : 'gi');
                    }

                    let match;
                    while ((match = searchRegex.exec(text)) !== null) {
                        matches.push({
                            start: match.index,
                            end: match.index + match[0].length
                        });
                    }

                    if (matches.length > 0) {
                        this.findMatches = matches;
                        this.currentFindIndex = (this.currentFindIndex + 1) % matches.length;
                        this.highlightMatches();
                    } else {
                        alert('No matches found');
                    }
                }

                highlightMatches() {
                    this.clearFindMatches();

                    const text = this.editor.textContent;
                    const fragment = document.createDocumentFragment();
                    let lastIndex = 0;

                    this.findMatches.forEach((match, index) => {
                        // Add text before match
                        fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.start)));

                        // Add highlighted match
                        const span = document.createElement('span');
                        span.className = 'find-match' + (index === this.currentFindIndex ? ' current' : '');
                        span.textContent = text.substring(match.start, match.end);
                        fragment.appendChild(span);

                        lastIndex = match.end;
                    });

                    // Add remaining text
                    fragment.appendChild(document.createTextNode(text.substring(lastIndex)));

                    // Replace editor content
                    this.editor.innerHTML = '';
                    this.editor.appendChild(fragment);

                    // Scroll current match into view
                    const currentMatch = this.editor.querySelector('.find-match.current');
                    if (currentMatch) {
                        currentMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }

                replace() {
                    const replaceText = document.getElementById('replaceInput').value;
                    const currentMatch = this.editor.querySelector('.find-match.current');

                    if (currentMatch) {
                        currentMatch.replaceWith(document.createTextNode(replaceText));
                        this.findMatches.splice(this.currentFindIndex, 1);
                        if (this.findMatches.length > 0) {
                            this.currentFindIndex = this.currentFindIndex % this.findMatches.length;
                            this.findNext();
                        } else {
                            this.clearFindMatches();
                        }
                    }
                }

                replaceAll() {
                    const findText = document.getElementById('findInput').value;
                    const replaceText = document.getElementById('replaceInput').value;
                    const matchCase = document.getElementById('matchCase').checked;
                    const wholeWord = document.getElementById('wholeWord').checked;

                    if (!findText) return;

                    let searchRegex;
                    if (wholeWord) {
                        searchRegex = new RegExp(`\\b${this.escapeRegExp(findText)}\\b`, matchCase ? 'g' : 'gi');
                    } else {
                        searchRegex = new RegExp(this.escapeRegExp(findText), matchCase ? 'g' : 'gi');
                    }

                    const newContent = this.editor.textContent.replace(searchRegex, replaceText);
                    this.editor.textContent = newContent;
                    this.clearFindMatches();
                }

                escapeRegExp(string) {
                    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                }

                increaseFontSize() {
                    const select = document.getElementById('fontSizeSelect');
                    const currentIndex = select.selectedIndex;
                    if (currentIndex < select.options.length - 1) {
                        select.selectedIndex = currentIndex + 1;
                        formatDoc('fontSize', select.value);
                    }
                }

                decreaseFontSize() {
                    const select = document.getElementById('fontSizeSelect');
                    const currentIndex = select.selectedIndex;
                    if (currentIndex > 0) {
                        select.selectedIndex = currentIndex - 1;
                        formatDoc('fontSize', select.value);
                    }
                }

                toggleStylesPanel() {
                    const panel = document.getElementById('stylesPanel');
                    panel.classList.toggle('visible');
                }

                applyStyle(styleName) {
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const paragraph = this.getClosestParagraph(range.commonAncestorContainer);

                    if (paragraph) {
                        // Remove existing styles
                        paragraph.classList.remove('heading1', 'heading2', 'heading3', 'quote', 'code');

                        if (styleName !== 'normal') {
                            paragraph.classList.add(styleName);
                        }
                    }
                }

                applyCharacterStyle(styleName) {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0) return;

                    const range = selection.getRangeAt(0);
                    if (range.collapsed) return;

                    const span = document.createElement('span');
                    span.classList.add(styleName);

                    const content = range.extractContents();
                    span.appendChild(content);
                    range.insertNode(span);

                    // Merge adjacent spans with same style
                    this.mergeAdjacentSpans();
                }

                mergeAdjacentSpans() {
                    const spans = this.editor.getElementsByTagName('span');
                    for (let i = spans.length - 1; i > 0; i--) {
                        const current = spans[i];
                        const previous = spans[i - 1];

                        if (current.previousSibling === previous &&
                            current.className === previous.className) {
                            previous.textContent += current.textContent;
                            current.remove();
                        }
                    }
                }

                clearFormatting() {
                    // Get the selected text
                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    const content = range.extractContents();

                    // Create a temporary div to hold the content
                    const div = document.createElement('div');
                    div.appendChild(content);

                    // Get the text content without formatting
                    const plainText = div.textContent;

                    // Insert the plain text back
                    const textNode = document.createTextNode(plainText);
                    range.insertNode(textNode);

                    // Collapse the selection to the end
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);

                    this.editor.focus();
                }

                async paste() {
                    try {
                        const text = await navigator.clipboard.readText();
                        const selection = window.getSelection();
                        const range = selection.getRangeAt(0);
                        range.deleteContents();
                        range.insertNode(document.createTextNode(text));
                        this.updateCharCount();
                    } catch (err) {
                        console.error('Failed to paste:', err);
                        // Fallback to execCommand for browsers that don't support clipboard API
                        document.execCommand('paste', false);
                    }
                }

                async cut() {
                    try {
                        const selection = window.getSelection();
                        const text = selection.toString();
                        await navigator.clipboard.writeText(text);
                        selection.getRangeAt(0).deleteContents();
                        this.updateCharCount();
                    } catch (err) {
                        console.error('Failed to cut:', err);
                        // Fallback to execCommand
                        document.execCommand('cut', false);
                    }
                }

                makeImageResizable(container) {
                    const img = container.querySelector('img');
                    const handles = container.querySelectorAll('.resize-handle');

                    handles.forEach(handle => {
                        handle.addEventListener('mousedown', e => {
                            e.preventDefault();
                            const startX = e.clientX;
                            const startY = e.clientY;
                            const startWidth = img.offsetWidth;
                            const startHeight = img.offsetHeight;
                            const handleClass = handle.className.split(' ')[1];

                            const onMouseMove = e => {
                                const deltaX = e.clientX - startX;
                                const deltaY = e.clientY - startY;

                                let newWidth = startWidth;
                                let newHeight = startHeight;

                                // Calculate new dimensions based on handle position
                                switch (handleClass) {
                                    case 'se':
                                        newWidth = startWidth + deltaX;
                                        newHeight = startHeight + deltaY;
                                        break;
                                    case 'sw':
                                        newWidth = startWidth - deltaX;
                                        newHeight = startHeight + deltaY;
                                        break;
                                    case 'ne':
                                        newWidth = startWidth + deltaX;
                                        newHeight = startHeight - deltaY;
                                        break;
                                    case 'nw':
                                        newWidth = startWidth - deltaX;
                                        newHeight = startHeight - deltaY;
                                        break;
                                }

                                // Maintain aspect ratio
                                const aspectRatio = startWidth / startHeight;
                                if (Math.abs(newWidth / newHeight - aspectRatio) > 0.1) {
                                    newHeight = newWidth / aspectRatio;
                                }

                                // Apply minimum size
                                if (newWidth >= 50 && newHeight >= 50) {
                                    img.style.width = `${newWidth}px`;
                                    img.style.height = `${newHeight}px`;
                                }
                            };

                            const onMouseUp = () => {
                                document.removeEventListener('mousemove', onMouseMove);
                                document.removeEventListener('mouseup', onMouseUp);
                            };

                            document.addEventListener('mousemove', onMouseMove);
                            document.addEventListener('mouseup', onMouseUp);
                        });
                    });
                }

                exportAsDocx() {
                    // Get content from editor
                    const content = this.editor.innerHTML;

                    // Create minimal Word document XML
                    const wordDoc = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body>${this.convertHtmlToWordML(content)}</w:body>
</w:document>`;

                    // Create content types XML
                    const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>`;

                    // Create rels file
                    const rels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="/word/document.xml"/>
</Relationships>`;

                    // Create ZIP file containing the Word document
                    const zip = new JSZip();
                    zip.file("[Content_Types].xml", contentTypes);
                    zip.file("_rels/.rels", rels);
                    zip.file("word/document.xml", wordDoc);

                    // Generate and download the DOCX file
                    zip.generateAsync({ type: "blob" })
                        .then(function (content) {
                            const link = document.createElement('a');
                            link.href = URL.createObjectURL(content);
                            link.download = "document.docx";
                            link.click();
                        });
                }

                convertHtmlToWordML(html) {
                    // Convert headings
                    html = html.replace(/<h([1-6])>(.*?)<\/h\1>/g, function (match, level, content) {
                        return `<w:p><w:pPr><w:pStyle w:val="Heading${level}"/></w:pPr><w:r><w:t xml:space="preserve">${content}</w:t></w:r></w:p>`;
                    });

                    // Convert lists
                    html = html.replace(/<ul>(.*?)<\/ul>/g, function (match, content) {
                        return content.replace(/<li>(.*?)<\/li>/g,
                            '<w:p><w:pPr><w:pStyle w:val="ListBullet"/></w:pPr><w:r><w:t xml:space="preserve">$1</w:t></w:r></w:p>'
                        );
                    });

                    html = html.replace(/<ol>(.*?)<\/ol>/g, function (match, content) {
                        return content.replace(/<li>(.*?)<\/li>/g,
                            '<w:p><w:pPr><w:pStyle w:val="ListNumber"/></w:pPr><w:r><w:t xml:space="preserve">$1</w:t></w:r></w:p>'
                        );
                    });

                    // Convert paragraphs and inline formatting
                    return html
                        .replace(/<p>(.*?)<\/p>/g, function (match, content) {
                            // Handle inline formatting
                            content = content
                                // Bold
                                .replace(/<b>(.*?)<\/b>/g,
                                    '</w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t xml:space="preserve">$1</w:t></w:r><w:r><w:t xml:space="preserve">'
                                )
                                // Italic
                                .replace(/<i>(.*?)<\/i>/g,
                                    '</w:t></w:r><w:r><w:rPr><w:i/></w:rPr><w:t xml:space="preserve">$1</w:t></w:r><w:r><w:t xml:space="preserve">'
                                )
                                // Underline
                                .replace(/<u>(.*?)<\/u>/g,
                                    '</w:t></w:r><w:r><w:rPr><w:u w:val="single"/></w:rPr><w:t xml:space="preserve">$1</w:t></w:r><w:r><w:t xml:space="preserve">'
                                )
                                // Strike-through
                                .replace(/<s>(.*?)<\/s>/g,
                                    '</w:t></w:r><w:r><w:rPr><w:strike/></w:rPr><w:t xml:space="preserve">$1</w:t></w:r><w:r><w:t xml:space="preserve">'
                                )
                                // Subscript
                                .replace(/<sub>(.*?)<\/sub>/g,
                                    '</w:t></w:r><w:r><w:rPr><w:vertAlign w:val="subscript"/></w:rPr><w:t xml:space="preserve">$1</w:t></w:r><w:r><w:t xml:space="preserve">'
                                )
                                // Superscript
                                .replace(/<sup>(.*?)<\/sup>/g,
                                    '</w:t></w:r><w:r><w:rPr><w:vertAlign w:val="superscript"/></w:rPr><w:t xml:space="preserve">$1</w:t></w:r><w:r><w:t xml:space="preserve">'
                                );
                            return `<w:p><w:r><w:t xml:space="preserve">${content}</w:t></w:r></w:p>`;
                        })
                        .replace(/<br\s*\/?>/g, '<w:r><w:br/></w:r>');
                }

                async copy() {
                    try {
                        const selection = window.getSelection();
                        const text = selection.toString();
                        await navigator.clipboard.writeText(text);
                    } catch (err) {
                        console.error('Failed to copy:', err);
                        // Fallback to execCommand
                        document.execCommand('copy', false);
                    }
                }

                insertImageFromFile(file) {
                    if (!file || !file.type.startsWith('image/')) {
                        alert('Please select a valid image file');
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const container = document.createElement('div');
                        container.className = 'resizable-image';

                        const img = document.createElement('img');
                        img.src = e.target.result;
                        img.style.maxWidth = '100%';
                        container.appendChild(img);

                        // Add resize handles
                        ['nw', 'ne', 'sw', 'se'].forEach(pos => {
                            const handle = document.createElement('div');
                            handle.className = `resize-handle ${pos}`;
                            container.appendChild(handle);
                        });

                        const selection = window.getSelection();
                        const range = selection.getRangeAt(0);
                        range.deleteContents();
                        range.insertNode(container);

                        // Add resize functionality
                        this.makeImageResizable(container);

                        // Move cursor after container
                        range.setStartAfter(container);
                        range.setEndAfter(container);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    };
                    reader.readAsDataURL(file);
                }

                // Table methods
                insertTable() {
                    const rows = parseInt(prompt('Number of rows:', '3')) || 3;
                    const cols = parseInt(prompt('Number of columns:', '3')) || 3;

                    const table = document.createElement('table');
                    table.className = 'table-theme-default';
                    const thead = document.createElement('thead');
                    const tbody = document.createElement('tbody');

                    // Create header row
                    const headerRow = document.createElement('tr');
                    for (let j = 0; j < cols; j++) {
                        const th = document.createElement('th');
                        th.textContent = `Header ${j + 1}`;
                        headerRow.appendChild(th);
                    }
                    thead.appendChild(headerRow);

                    // Create body rows
                    for (let i = 0; i < rows - 1; i++) {
                        const row = document.createElement('tr');
                        for (let j = 0; j < cols; j++) {
                            const td = document.createElement('td');
                            td.textContent = `Cell ${i + 1},${j + 1}`;
                            row.appendChild(td);
                        }
                        tbody.appendChild(row);
                    }

                    table.appendChild(thead);
                    table.appendChild(tbody);

                    const selection = window.getSelection();
                    const range = selection.getRangeAt(0);
                    range.deleteContents();
                    range.insertNode(table);

                    this.editor.focus();
                }

                getCurrentCell() {
                    const selection = window.getSelection();
                    let node = selection.anchorNode;
                    while (node && node.nodeName !== 'TD' && node.nodeName !== 'TH') {
                        node = node.parentNode;
                    }
                    return node;
                }

                getCurrentRow() {
                    const cell = this.getCurrentCell();
                    return cell ? cell.parentNode : null;
                }

                getCurrentTable() {
                    const cell = this.getCurrentCell();
                    if (!cell) return null;
                    let node = cell;
                    while (node && node.nodeName !== 'TABLE') {
                        node = node.parentNode;
                    }
                    return node;
                }

                handleClick() {
                    // Show/hide table controls based on cursor position
                    const tableGroup = document.getElementById('tableGroup');
                    const inTable = this.getCurrentTable() !== null;
                    tableGroup.style.display = inTable ? 'flex' : 'none';
                }

                addRow() {
                    const currentRow = this.getCurrentRow();
                    if (!currentRow) return;

                    const newRow = document.createElement('tr');
                    const cells = currentRow.cells;

                    for (let i = 0; i < cells.length; i++) {
                        const cell = document.createElement('td');
                        cell.textContent = 'New cell';
                        newRow.appendChild(cell);
                    }

                    currentRow.parentNode.insertBefore(newRow, currentRow.nextSibling);
                }

                addColumn() {
                    const table = this.getCurrentTable();
                    if (!table) return;

                    const rows = table.rows;
                    for (let i = 0; i < rows.length; i++) {
                        const cell = document.createElement(i === 0 ? 'th' : 'td');
                        cell.textContent = i === 0 ? 'New Header' : 'New cell';
                        rows[i].appendChild(cell);
                    }
                }

                deleteRow() {
                    const currentRow = this.getCurrentRow();
                    if (!currentRow || currentRow.parentNode.rows.length <= 2) return;
                    currentRow.remove();
                }

                deleteColumn() {
                    const cell = this.getCurrentCell();
                    if (!cell) return;

                    const table = this.getCurrentTable();
                    const index = cell.cellIndex;

                    if (table.rows[0].cells.length <= 1) return;

                    for (let i = 0; i < table.rows.length; i++) {
                        table.rows[i].deleteCell(index);
                    }
                }

                applyTableTheme(theme) {
                    const table = this.getCurrentTable();
                    if (!table) return;

                    // Remove any existing theme classes
                    table.classList.remove(
                        'table-theme-default',
                        'table-theme-professional',
                        'table-theme-minimal',
                        'table-theme-colorful',
                        'table-theme-grid'
                    );

                    // Apply new theme
                    table.classList.add(`table-theme-${theme}`);
                }

                addComment() {
                    const selection = window.getSelection();
                    if (selection.rangeCount === 0 || selection.toString().trim() === '') {
                        alert('Please select some text to comment on');
                        return;
                    }

                    const commentText = prompt('Enter your comment:');
                    if (!commentText) return;

                    const range = selection.getRangeAt(0);
                    const span = document.createElement('span');
                    span.className = 'commented-text';
                    span.dataset.commentId = this.nextCommentId;

                    const indicator = document.createElement('span');
                    indicator.className = 'comment-indicator';
                    span.appendChild(indicator);

                    range.surroundContents(span);

                    const comment = {
                        id: this.nextCommentId,
                        text: commentText,
                        author: 'Current User',
                        date: new Date().toISOString(),
                        selection: span.textContent
                    };

                    this.comments.push(comment);
                    this.nextCommentId++;

                    this.updateCommentsList();
                    this.toggleComments(true);
                }

                deleteComment(commentId) {
                    // Remove the comment from the comments array
                    this.comments = this.comments.filter(comment => comment.id !== commentId);

                    // Remove the comment highlight from the text
                    const commentedText = this.editor.querySelector(`[data-comment-id="${commentId}"]`);
                    if (commentedText) {
                        const textNode = document.createTextNode(commentedText.textContent);
                        commentedText.parentNode.replaceChild(textNode, commentedText);
                    }

                    this.updateCommentsList();
                }

                checkForDeletedComments() {
                    const currentCommentElements = this.editor.querySelectorAll('[data-comment-id]');
                    const currentIds = new Set(Array.from(currentCommentElements).map(el => parseInt(el.dataset.commentId)));

                    // Find comments that no longer have corresponding elements
                    this.comments = this.comments.filter(comment => {
                        if (!currentIds.has(comment.id)) {
                            this.deletedCommentIds.add(comment.id);
                            return false;
                        }
                        return true;
                    });

                    if (this.deletedCommentIds.size > 0) {
                        this.updateCommentsList();
                        this.deletedCommentIds.clear();
                    }
                }

                toggleComments(show = null) {
                    const panel = document.getElementById('commentsPanel');
                    if (show === null) {
                        panel.classList.toggle('visible');
                    } else {
                        panel.classList.toggle('visible', show);
                    }

                    const button = document.querySelector('button[title="Show Comments"]');
                    button.classList.toggle('active', panel.classList.contains('visible'));
                }

                updateCommentsList() {
                    const commentsList = document.getElementById('commentsList');
                    commentsList.innerHTML = '';

                    this.comments.forEach(comment => {
                        const entry = document.createElement('div');
                        entry.className = 'comment-entry';
                        entry.innerHTML = `
                            <div class="comment-text">${comment.text}</div>
                            <div class="comment-meta">
                                <div>On: "${comment.selection}"</div>
                                <div>By: ${comment.author}</div>
                                <div>Date: ${new Date(comment.date).toLocaleString()}</div>
                                <button onclick="editor.deleteComment(${comment.id})" class="delete-comment">Delete</button>
                            </div>
                        `;

                        entry.addEventListener('mouseenter', () => {
                            const commentedText = this.editor.querySelector(`[data-comment-id="${comment.id}"]`);
                            if (commentedText) {
                                commentedText.classList.add('highlight');
                            }
                        });

                        entry.addEventListener('mouseleave', () => {
                            const commentedText = this.editor.querySelector(`[data-comment-id="${comment.id}"]`);
                            if (commentedText) {
                                commentedText.classList.remove('highlight');
                            }
                        });

                        commentsList.appendChild(entry);
                    });
                }

                toggleSpellCheck() {
                    this.spellCheckEnabled = !this.spellCheckEnabled;
                    this.editor.spellcheck = this.spellCheckEnabled;

                    // Visual feedback
                    const button = document.querySelector('button[title="Spell Check"]');
                    button.classList.toggle('active', this.spellCheckEnabled);
                }

                toggleAutoCorrect() {
                    this.autoCorrectEnabled = !this.autoCorrectEnabled;
                    this.editor.setAttribute('autocorrect', this.autoCorrectEnabled ? 'on' : 'off');

                    // Visual feedback
                    const button = document.querySelector('button[title="Auto Correct"]');
                    button.classList.toggle('active', this.autoCorrectEnabled);
                }
            }

            // Initialize the editor
            const editor = new SimpleEditor('editor');

            // Formatting functions
            function formatDoc(command, value = null) {
                document.execCommand(command, false, value);
                editor.editor.focus();
            }

            function createNewParagraph() {
                editor.createNewParagraph();
                editor.editor.focus();
            }
        </script>
</body>

</html>